{"ast":null,"code":"import * as Yup from \"yup\";\nimport moment from \"moment\";\nexport const createSchema = validations => {\n  let shape = {};\n\n  for (let i = 0; i < validations.length; i++) {\n    let type = validations[i].type;\n    let key = validations[i].name;\n    let label = validations[i].label;\n    let required = validations[i].required;\n    let req_msg = validations[i].req_msg;\n    let err_msg = validations[i].err_msg;\n    let matches = validations[i].matches;\n    let min = validations[i].min;\n    let max = validations[i].max;\n\n    if (type === \"email\") {\n      shape[key] = Yup.string().email(err_msg || \"Please provide a valid email addess\");\n    } else if (type === \"number\") {\n      shape[key] = Yup.number();\n      if (min < 4) shape[key] = shape[key].min(min, \"Minimum length should \" + min + \"\");\n    } else if (_type === \"full_name\") {\n      shape[_key] = Yup.mixed().test(\"match\", \"Full Name is required\", function (name) {\n        return name && name[\"First name\"] && name[\"Last name\"];\n      });\n    } else {\n      shape[_key] = Yup.string();\n      if (_matches) shape[_key] = shape[_key].matches(_matches, _err_msg || \"Invalid value\");\n    }\n\n    if (_required) {\n      shape[_key] = shape[_key].required(_req_msg || `The field ${_label || _key} is required`);\n    }\n\n    if (_key === \"cpassword\") {\n      shape[\"cpassword\"] = Yup.mixed().test(\"match\", \"password and re-enter password does not match\", function (password) {\n        return password === this.parent.password;\n      });\n    }\n  }\n\n  return Yup.object().shape(shape);\n};\nexport const password_conditions = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])(?=.{8,})/;\nexport const verifyPassword = value => {\n  if (value.length < 8 || !/[a-z]/.test(value) || !/[A-Z]/.test(value) || !/[0-9]/.test(value) || !/[!@#\\$%\\^&\\*]/.test(value)) {\n    return \"Password should contain : \\n Minimum length of 8 characters \\n Atleast 1 Numeric character \\n Atleast 1 Uppercase letter \\n Atleast 1 Lowercase letter \\n Atleast 1 Special character\";\n  }\n\n  return \"\";\n};\nexport const createInitialValues = fields => {\n  let initialValues = {};\n  fields && fields.map(field => {\n    if (field.type === \"CheckBox\") {\n      field.options.map(option => {\n        initialValues[option.name] = option.value;\n      });\n    } else {\n      initialValues[field.name] = field.value;\n    }\n  });\n  return initialValues;\n};","map":{"version":3,"sources":["/home/ellocent/Downloads/formiklogin/formiklogin/src/Form Components/validations.js"],"names":["Yup","moment","createSchema","validations","shape","i","length","type","key","name","label","required","req_msg","err_msg","matches","min","max","string","email","number","_type","_key","mixed","test","_matches","_err_msg","_required","_req_msg","_label","password","parent","object","password_conditions","verifyPassword","value","createInitialValues","fields","initialValues","map","field","options","option"],"mappings":"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","sourcesContent":["import * as Yup from \"yup\";\nimport moment from \"moment\";\n\nexport const createSchema = (validations) => {\n  let shape = {};\n  for (let i = 0; i < validations.length; i++) {\n    let type = validations[i].type;\n    let key = validations[i].name;\n    let label = validations[i].label;\n    let required = validations[i].required;\n    let req_msg = validations[i].req_msg;\n    let err_msg = validations[i].err_msg;\n    let matches = validations[i].matches;\n    let min = validations[i].min;\n    let max = validations[i].max;\n\n    if (type === \"email\") {\n      shape[key] = Yup.string().email(\n        err_msg || \"Please provide a valid email addess\"\n      );\n    } else if (type === \"number\") {\n      shape[key] = Yup.number();\n      if (min<4)\n        shape[key] = shape[key].min(\n          min,\n          \"Minimum length should \" + min + \"\"\n        );\n     \n    } else if (_type === \"full_name\") {\n      shape[_key] = Yup.mixed().test(\n        \"match\",\n        \"Full Name is required\",\n        function (name) {\n          return name && name[\"First name\"] && name[\"Last name\"];\n        }\n      );\n    } \n     else {\n      shape[_key] = Yup.string();\n      if (_matches)\n        shape[_key] = shape[_key].matches(\n          _matches,\n          _err_msg || \"Invalid value\"\n        );\n    }\n    if (_required) {\n      shape[_key] = shape[_key].required(\n        _req_msg || `The field ${_label || _key} is required`\n      );\n    }\n    if (_key === \"cpassword\") {\n      shape[\"cpassword\"] = Yup.mixed().test(\n        \"match\",\n        \"password and re-enter password does not match\",\n        function (password) {\n          return password === this.parent.password;\n        }\n      );\n    }\n  }\n\n  return Yup.object().shape(shape);\n};\n\nexport const password_conditions = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])(?=.{8,})/;\n\nexport const verifyPassword = (value) => {\n  if (\n    value.length < 8 ||\n    !/[a-z]/.test(value) ||\n    !/[A-Z]/.test(value) ||\n    !/[0-9]/.test(value) ||\n    !/[!@#\\$%\\^&\\*]/.test(value)\n  ) {\n    return \"Password should contain : \\n Minimum length of 8 characters \\n Atleast 1 Numeric character \\n Atleast 1 Uppercase letter \\n Atleast 1 Lowercase letter \\n Atleast 1 Special character\";\n  }\n\n  return \"\";\n};\n\nexport const createInitialValues = (fields) => {\n  let initialValues = {};\n  fields &&\n    fields.map((field) => {\n      if (field.type === \"CheckBox\") {\n        field.options.map((option) => {\n          initialValues[option.name] = option.value;\n        });\n      } else {\n        initialValues[field.name] = field.value;\n      }\n    });\n  return initialValues;\n};\n"]},"metadata":{},"sourceType":"module"}