{"ast":null,"code":"import * as Yup from \"yup\";\nimport moment from \"moment\";\nexport const createSchema = validations => {\n  let shape = {};\n\n  for (let i = 0; i < validations.length; i++) {\n    let type = validations[i].type;\n    let key = validations[i].name;\n    let label = validations[i].label;\n    let required = validations[i].required;\n    let req_msg = validations[i].req_msg;\n    let err_msg = validations[i].err_msg;\n    let matches = validations[i].matches;\n    let min = validations[i].min;\n    let max = validations[i].max;\n\n    if (type === \"email\") {\n      shape[key] = Yup.string().email(err_msg || \"Please provide a valid email addess\");\n    } else if (type === \"number\") {\n      shape[key] = Yup.number();\n      if (min < 4) shape[key] = shape[key].min(min, \"Minimum length should \" + min + \"\");\n    } else if (type === \"name\") {\n      shape[key] = Yup.mixed().test(\"match\", \" Name is required\", function (name) {\n        return name;\n      });\n    } else {\n      shape[key] = Yup.string();\n      if (matches) shape[key] = shape[key].matches(matches, err_msg || \"Invalid value\");\n    }\n\n    if (required) {\n      shape[key] = shape[key].required(req_msg || `The field ${label || key} is required`);\n    }\n\n    if (key === \"cpassword\") {\n      shape[\"cpassword\"] = Yup.mixed().test(\"match\", \"password and re-enter password does not match\", function (password) {\n        return password === this.parent.password;\n      });\n    }\n  }\n\n  return Yup.object().shape(shape);\n};\nexport const createInitialValues = fields => {\n  let initialValues = {};\n  fields && fields.map(field => {\n    if (field.type === \"CheckBox\") {\n      field.options.map(option => {\n        initialValues[option.name] = option.value;\n      });\n    } else {\n      initialValues[field.name] = field.value;\n    }\n  });\n  return initialValues;\n};","map":{"version":3,"sources":["/home/ellocent/Downloads/formiklogin/formiklogin/src/Form Components/validations.js"],"names":["Yup","moment","createSchema","validations","shape","i","length","type","key","name","label","required","req_msg","err_msg","matches","min","max","string","email","number","mixed","test","password","parent","object","createInitialValues","fields","initialValues","map","field","options","option","value"],"mappings":"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","sourcesContent":["import * as Yup from \"yup\";\nimport moment from \"moment\";\n\nexport const createSchema = (validations) => {\n  let shape = {};\n  for (let i = 0; i < validations.length; i++) {\n    let type = validations[i].type;\n    let key = validations[i].name;\n    let label = validations[i].label;\n    let required = validations[i].required;\n    let req_msg = validations[i].req_msg;\n    let err_msg = validations[i].err_msg;\n    let matches = validations[i].matches;\n    let min = validations[i].min;\n    let max = validations[i].max;\n\n    if (type === \"email\") {\n      shape[key] = Yup.string().email(\n        err_msg || \"Please provide a valid email addess\"\n      );\n    } else if (type === \"number\") {\n      shape[key] = Yup.number();\n      if (min<4)\n        shape[key] = shape[key].min(\n          min,\n          \"Minimum length should \" + min + \"\"\n        );\n     \n    } else if (type === \"name\") {\n      shape[key] = Yup.mixed().test(\n        \"match\",\n        \" Name is required\",\n        function (name) {\n          return name ;\n        }\n      );\n    } \n     else {\n      shape[key] = Yup.string();\n      if (matches)\n        shape[key] = shape[key].matches(\n          matches,\n          err_msg || \"Invalid value\"\n        );\n    }\n    if (required) {\n      shape[key] = shape[key].required(\n        req_msg || `The field ${label || key} is required`\n      );\n    }\n    if (key === \"cpassword\") {\n      shape[\"cpassword\"] = Yup.mixed().test(\n        \"match\",\n        \"password and re-enter password does not match\",\n        function (password) {\n          return password === this.parent.password;\n        }\n      );\n    }\n  }\n\n  return Yup.object().shape(shape);\n};\n\n\n\n\n\nexport const createInitialValues = (fields) => {\n  let initialValues = {};\n  fields &&\n    fields.map((field) => {\n      if (field.type === \"CheckBox\") {\n        field.options.map((option) => {\n          initialValues[option.name] = option.value;\n        });\n      } else {\n        initialValues[field.name] = field.value;\n      }\n    });\n  return initialValues;\n};\n"]},"metadata":{},"sourceType":"module"}